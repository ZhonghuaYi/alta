/*!
\page tutorials Tutorials
\tableofcontents

### Fitting using the command line

#### 1D Rational interpolation

The \a data2brdf allows to perform a fitting procedure by converting a \ref data object into a brdf object (also named \ref function).

First, download the Kirby2 dataset in ALTA format: <a href="http://alta.gforge.inria.fr/data/Kirby2.dat">Kirby2.dat</a>. Save this file in <i>$ALTA/data/1d/NIST/Kirby2</i>.

    $ ./build/data2brdf --input ../data/1d/NIST/Kirby2/Kirby2.dat --output Kirby.brdf --fitter rational_fitter_eigen

The result can be exported using the \a brdf2data commands.

    $ ./build/brdf2data --input Kirby.brdf --output Kirby.dat --data-file ../data/1d/NIST/Kirby2/Kirby2.dat

The \a brdf2data allows you to export a function into a data file. If no data plugin is specified, the ALTA format is used which is gnuplot compliant. The position of evaluation for the function are taken from a specified data file (here the original Kirby2 file).

You should obtain gnuplot data files like the following image:

@htmlonly
<center>
<img src="Kirby2.png" alt="Kirby2" height="512px"/>
</center>
@endhtmlonly

To convert this brdf file to be used in another software (here matlab), you will need the following command:

    $ ./build/brdf2brdf --input Kirby.brdf --output Kirby.m --export matlab

\a brdf2brdf converts an ALTA brdf file into another format such as Matlab m file, C++ code, or BRDF Explorer shader. Note that this tool cannot convert to another ALTA file (e.g., converting a Blinn lobe to a Beckmann
distribution).


#### 2D Rational interpolation of BRDFs

In this example, we will show how to perform data conversion and vertical segments interpolation of the `gold-metallic-paint` material from the MERL database using the command line programs on an OSX platform. First download the binary file [gold-metallic-paint.binary](http://people.csail.mit.edu/wojciech/BRDFDatabase/brdfs/gold-metallic-paint.binary) and copy it to the `$ALTA/data/3d/merl` directory.

The first command we will execute will convert the three dimensional data in a 2D slice in the halfway vector parametrization:

    $ ./build/data2data --input ../data/3d/merl/gold-metallic-paint.binary --in-data data_merl --output ../data/2d/merl/gold-met.exr --out-data data_brdf_slice

The \a data_brdf_slice plugin permits to represent BRDF slices using HDR image files (.exr format), while the \a data_merl plugin opens MERL's binary format. This is the format used by Pacanowski et al. [[2012]](http://hal.inria.fr/hal-00678885/en) to perform fitting. The output of this command should look like:

@htmlonly
<center>
<img src="gold-met-merl.png" alt="gold-metallic-paint slice" />
</center>
@endhtmlonly

Then, we search for a fit of this 2D BRDF slice using the \a rational_fitter_parallel and a Chebychev basis for 60 to 100 coefficients in total:

    $ ./build/data2brdf --input ../data/2d/merl/gold-met.exr --data data_brdf_slice --output gold-met.brdf --fitter rational_fitter_parallel --func rational_function_chebychev --min-np 60 -- np 100

This outputs a BRDF file which cannot be displayed directly. To see the result of our fitting, we can export this BRDF into the BRDF image slice format:

    $ ./build/brdf2data --input gold-met.brdf --output gold-met-rat.exr --data data_brdf_slice

It is now possible to perform side by side comparison of the original data, and the interpolated rational function:

@htmlonly
<center>
  <table  border="0" style='text-align:center'>
  <tr>
    <td>
      <img src="gold-met-merl.png" alt="gold-metallic-paint slice" />
    </td>
    <td>
      <img src="gold-met-rat.png" alt="gold-metallic-paint slice fitting using R-BRDFs" />
    </td>
  </tr>
  </table>
</center>
@endhtmlonly


#### Non-linear fitting

In this example, we use Google's <a href="http://code.google.com/p/ceres-solver/">CERES</a> nonlinear fitter to approximate the blue metallic paint from the <a href="http://www.merl.com/brdf/">MERL database</a> using a Lafortune lobe (Note that we do not provide the data in ALTA package, you will have to download it). The resulting BRDF is exported in a shader format compatible with BRDF Explorer.

     $ ./build/data2brdf --data data_merl --input ../data/3d/merl/blue-metallic-paint.binary --output blue-met.brdf --fitter nonlinear_fitter_ceres --func nonlinear_function_lafortune  --export explorer

This command line is rather long. To help you design complex command line in a more intuitive way, ALTA comes with a python script that creates command lines from XML files (see \ref format for an example).


### Python scripts

All actions can be done using Python scripts. We provide a python interface that can be loaded with:

	>>> import alta

The complete python interface of ALTA can be found here : \ref python.


### XML scripts

Here is the script to perform the same fitting as the previous example. It performs the fitting of the blue metallic paint from the MERL database using a Beckmann lobe (note there is no shadowing term, nor Fresnel term):

~~~{.xml}
<?xml version="1.0"?>
<alta>
	<action name="data2brdf">
		<!-- Input and output arguments of the action -->
		<input  name="../data/3d/merl/blue-metallic-paint.binary" />
		<output name="./results/3d/merl/blue-mettalic-paint.brdf" />

		<!-- Define the function to use -->
		<function name="nonlinear_function_diffuse" />
		<function name="nonlinear_function_beckmann" />

		<!-- Define the ftting procedure to use -->
		<plugin type="fitter" name="nonlinear_fitter_ceres" />

		<!-- Define the data loader to use -->
		<plugin type="data" name="data_merl" />

		<!-- Parameter -->
		<parameter name="export" value="explorer" />
	</action>
</alta>
~~~

In this XML example, it is possible to perform fit using a compound function by concatenating multiple function plugins. This is equivalent to providing a list of plugins to the <code>\-\-func</code> argument: <code>\-\-func [nonlinear_function_diffuse, nonlinear_function_lafortune]</code>.

You can perform this action using the following command, assuming that the
xml script is in file `script.xml`:

    $ ./scripts/xml_cmd.py script.xml

You can put multiple `<action>` commands in the xml file. Those commands will be executed in order.


### Moment analysis using the command line

The \a data2moment allows to perform a moment analysis on a \ref data object. It can be useful to determine whether a given data correspond to a separable function along its different axis.

    $ ./build/data2moments --input ../data/1d/NIST/Kirby2/Kirby2.dat --data ./build/libdata_interpolant.so


### Using the C++ interface

It is possible to create your own programs and make use of ALTA's plugin possibilities. To do so, you only need to link you program with the core library (`libcore.a` on GNU/Linux). The core library provides all the generic objects for \ref function, \ref data, and \ref fitter. You can load a plugin and create an object using the \ref plugins_manager.

The following program produces slices of data files and outputs it on a gnuplot compliant data file. It requires an interpolant data format such as \ref data_merl, \ref data_interpolant (our internal data format is not):

~~~{.cpp}
#include <core/args.h>
#include <core/data.h>
#include <core/function.h>
#include <core/fitter.h>
#include <core/plugins_manager.h>
#include <core/common.h>

#include <iostream>
#include <cmath>

int main(int argc, char** argv) {
    arguments args(argc, argv);

    ptr<data> d = plugins_manager::get_data(args["data"]);
    d->load(args["data-file"]);

    std::ofstream file(args["output"].c_str(), std::ios_base::trunc);

	double theta_in = -(M_PI/180) * (double)args.get_float("theta", 0.0f);
	double phi_in   =  (M_PI/180) * (double)args.get_float("phi", 0.0f);
	vec cart(6);
	cart[0] = cos(phi_in)*sin(theta_in);
	cart[1] = sin(phi_in)*sin(theta_in);
	cart[2] = cos(theta_in);

	const int N = 1000;
	for(int i=0; i<N; ++i) {
		const double theta_out = M_PI * (i / (double)(N-1) - 0.5);
		const double phi_out   = 0.0;
		cart[3] = cos(phi_out)*sin(theta_out);
		cart[4] = sin(phi_out)*sin(theta_out);
		cart[5] = cos(theta_out);

		params::convert(&cart[0], params::CARTESIAN, d->parametrization(), &x[0]);
		vec v = d->value(x) ;

		file << theta_out << "\t";
		for(int u=0; u<d->dimY(); ++u) {
			file << v[u] << "\t" ;
		}
		file << std::endl ;
	}
}
~~~

The \ref arguments object allow to parse the command line and read options. The \ref plugins_manager allows to create plugin objects from shared object files. In this example, when data objects are not defined in the same parametrization than the data point we want to evaluate, the convert function from the \ref params class can be used. We advise to use it all the time.






\page tutorial1 Non-Linear Fitting Tutorial

In this tutorial, we will see how to fit a Blinn-Phong BRDF model to the `blue-metallic-paint` dataset from the [MERL][merl] library (please click on the picture to change the horizontal position of the vertical cut):
@htmlonly
<center>
<table>
   <tr>
      <td><div class="image" id="compare-nonlinear"></div></td>
   </tr>
   <tr>
      <td style="text-align:center"><tt>blue-metallic-paint</tt></td>
   </tr>
</table>
</center>
@endhtmlonly


### Data conversion

The first step is download and convert the dataset into ALTA internal format. This will ease the manipulation of data afterwards:

    $ wget http://people.csail.mit.edu/wojciech/BRDFDatabase/brdfs/blue-metallic-paint.binary

will download the dataset and

    $ data2data --input blue-metallic-paint.binary --in-data data_merl --output blue-metallic-paint.dat

this conversion requires to use the \ref data_merl plugin to load MERL binary files and convert them into ALTA's internal format. This format allows to filter elements using the `min` and `max` option for example. Those options enable to specify the minimun and maximum abscissa of the data used during fitting. For example:

    $ data2data --input blue-metallic-paint.dat --max [0.8, 0.01, 0.01] --output blue-filtered.dat

will remove data elements such that \f$ \theta_H > 0.8 \;\mbox{rad} \f$,  \f$ \theta_D > 0.01 \;\mbox{rad} \f$, and \f$ \phi_D > 0.01 \;\mbox{rad} \f$. This will allow us to fit only the configuration close to \f$ L = V \f$.


### Fitting

Finally, we fit the sum of a Lambertian term and the Blinn-Phong lobe. To generate this compound we use the bracket operator in command line and the \ref nonlinear_function_diffuse and \ref nonlinear_function_blinn plugins:

    $ data2brdf --input blue-filtered.dat --output blue-metallic-paint.func --func [nonlinear_function_diffuse, nonlinear_function_blinn] --fitter nonlinear_fitter_ceres

In this example, we used the \ref nonlinear_fitter_ceres fitting plugin, but any other nonlinear fitter would be good as well. Notice that you might experience different results depending of the fitter you used, due to the difference in the underlying fitting procedure (CERES uses a Levenberg-Marquardt algorithm).

@htmlonly
<script type="text/javascript" src="script.js"></script>
<script type="text/javascript">
var compareNonlinear = Compare('compare-nonlinear', 250, 200);
compareNonlinear.add('nonlinear_example_01_ref.png', 'MERL');
compareNonlinear.add('nonlinear_example_01_alta.png', 'Blinn');
compareNonlinear.update();
</script>
@endhtmlonly




\page tutorial2 Rational Fitting Tutorial

In this tutorial, we will see how to fit a rational BRDF model to the `gold-metallic-paint` dataset from the [MERL][merl] library (please click on the picture to change the horizontal position of the vertical cut):
@htmlonly
<center>
<table>
   <tr>
      <td><div class="image" id="compare-rational"></div></td>
   </tr>
   <tr>
      <td style="text-align:center"><tt>gold-metallic-paint</tt></td>
   </tr>
</table>
</center>
@endhtmlonly


### Data conversion

The first step is download and convert the dataset into ALTA internal format. This will ease the manipulation of data afterwards:

    $ wget http://people.csail.mit.edu/wojciech/BRDFDatabase/brdfs/gold-metallic-paint.binary

will download the dataset and

    $ data2data --input gold-metallic-paint.binary --in-data data_merl --output gold-metallic-paint.exr --out-data data_brdf_slice

this conversion requires to use the \ref data_merl and \ref data_brdf_slice plugins to load MERL binary files and convert them into and HDR image slice.


### Fitting

We use the least square rational fitter: \ref rational_fitter_leastsquare. This fitter alternatively fit the numerator and the denominator of the rational function. We also use a Chebychev polynomial as the basis for the rational function by selecting the \ref rational_function_chebychev plugin using 100 coefficients at the numerator and 50 at the denominator:

    $ data2brdf --input gold-metallic-paint.exr --output gold-metallic-paint.func --func rational_function_chebychev --fitter rational_fitter_leastsquare --np 100 --nq 50

@htmlonly
<script type="text/javascript" src="script.js"></script>
<script type="text/javascript">
var compareRational = Compare('compare-rational', 250, 200);
compareRational.add('rational_example_01_ref.png', 'MERL');
compareRational.add('rational_example_01_alta.png', 'Rational BRDF');
compareRational.update();
</script>
@endhtmlonly



\page tutorial3 Data Conversion Tutorial

In this tutorial, we will see how to convert data from the `red-fabric` dataset from the [MERL][merl] library to a 2D slice in different parametrizations (please click on the picture to change the horizontal position of the vertical cut):
@htmlonly
<center>
<table>
   <tr>
      <td><div class="image" id="compare-data"></div></td>
   </tr>
   <tr>
      <td style="text-align:center"><tt>red-fabric</tt></td>
   </tr>
</table>
</center>
@endhtmlonly


### Data conversion

The first step is download and convert the dataset into ALTA internal format. This will ease the manipulation of data afterwards:

    $ wget http://people.csail.mit.edu/wojciech/BRDFDatabase/brdfs/red-fabric.binary

will download the dataset and

    $ data2data --input red-fabric.binary --in-data data_merl --output red-fabric.exr --out-data data_brdf_slice

this conversion requires to use the \ref data_merl and \ref data_brdf_slice plugins to load MERL binary files and convert them into and HDR image slice. By default, the \ref data_brdf_slice exports in the  \ref params::STARK_2D "STARK_2D" parametrization. But it is also possible to use other kind of 2D parametrization such as \ref params::RUSIN_TH_TD "RUSIN_TH_TD" using the `--param [string]` option (see \ref params for the complete list): 

    $ data2data --input red-fabric.binary --in-data data_merl --output red-fabric.exr --out-data data_brdf_slice --param RUSIN_TH_TD

It is also possible to select 3D parametrization and complete the third component with the `--angle [float]` parameter. Note that this parameter accept angles in degrees:

    $ data2data --input red-fabric.binary --in-data data_merl --output red-fabric.exr --out-data data_brdf_slice --param RUSIN_TH_TD_PD --angle 90

@htmlonly
<script type="text/javascript" src="script.js"></script>
<script type="text/javascript">
var compareRational = Compare('compare-data', 250, 200);
compareRational.add('data_example_01_ref.png', 'MERL');
compareRational.add('data_example_01_alta.png', 'Stark 2D');
compareRational.update();
</script>
@endhtmlonly



  [merl]: http://people.csail.mit.edu/wojciech/BRDFDatabase/
  [gold-paint]: http://people.csail.mit.edu/wojciech/BRDFDatabase/brdfs/gold-metallic-paint.binary
  [blue-paint]: http://people.csail.mit.edu/wojciech/BRDFDatabase/brdfs/blue-metallic-paint.binary


*/
